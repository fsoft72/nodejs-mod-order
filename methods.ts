/*
 * This file has been generated by flow2code
 * See: https://flow.liwe.org
 */

import { ILRequest, ILResponse, LCback, ILiweConfig, ILError, ILiWE } from '../../liwe/types';
import { $l } from '../../liwe/locale';
import { system_permissions_register } from '../system/methods';

import {
	Order, OrderFull, OrderFullKeys, OrderItem, OrderItemKeys,
	OrderKeys, OrderPaymentLog, OrderPaymentLogKeys, OrderPaymentStatus, OrderStatus,
} from './types';

import _module_perms from './perms';

let _liwe: ILiWE = null;

const _ = ( txt: string, vals: any = null, plural = false ) => {
	return $l( txt, vals, plural, "order" );
};

const COLL_ORDERS = "orders";
const COLL_ORDER_ITEMS = "order_items";
const COLL_ORDER_LOG = "order_log";

/*=== f2c_start __file_header === */
import { system_domain_get_by_session } from '../system/methods';
import { Product } from '../product/types';
import { product_get } from '../product/methods';
import { date_format, keys_filter, mkid } from '../../liwe/utils';
import { user_get } from '../user/methods';
import { User, UserSmall } from '../user/types';
import { challenge_check, keys_remove } from '../../liwe/utils';
import { adb_del_one, adb_record_add, adb_find_one, adb_find_all, adb_query_all, adb_del_all, adb_collection_init } from '../../liwe/db/arango';
import { ORDER_EVENT_PAID } from './events';
import { liwe_event_emit } from '../../liwe/events';
import { perm_available } from '../../liwe/auth';


/**
 * Generates a unique code based on the current date and time in the format yyyymmddHHMMSS.
 * @returns {string} The generated code.
 */
const mkcode = () => {
	const d = date_format( new Date(), 'yyyymmddHHMMSS' );

	return d;
};

/**
 * Retrieves an order by ID, code, or user ID.
 * If no order is found and a user ID is provided, a new order is created.
 * @param req - The request object.
 * @param id - The ID of the order to retrieve.
 * @param code - The code of the order to retrieve.
 * @param id_user - The ID of the user associated with the order.
 * @param full - Whether or not to include the user object in the returned order.
 * @returns The retrieved or created order.
 */
const _order_get = async ( req: ILRequest, id?: string, code?: string, id_user?: string, full: boolean = false ) => {
	let order: Order = null;
	const domain = await system_domain_get_by_session( req );
	let user: User = null;
	let userSmall: UserSmall = null;

	if ( !id_user ) id_user = req?.user?.id || 'xxx';

	console.log( "=== ORDER GET: ", { id_user, id, code } );

	if ( id || code ) {
		order = await adb_find_one( _liwe.db, COLL_ORDERS, { id, code } );
	}

	if ( !order && id_user && id_user != 'xxx' && id_user.length > 4 ) {
		order = await adb_find_one( req.db, COLL_ORDERS, { id_user, status: OrderStatus.new } );
	}

	if ( !order && id_user && id_user != 'xxx' ) {
		user = await user_get( id_user );

		userSmall = {
			id: user.id,
			domain: user.domain,
			name: user.name,
			lastname: user.lastname,
			email: user.email,
			username: user.username,
		};

		order = { id: mkid( 'order' ), id_user, domain: domain.code, status: OrderStatus.new, code: mkcode(), user: userSmall };
		order = await adb_record_add( req.db, COLL_ORDERS, order );
	}

	return order;
};

/**
 * Retrieves a full order object with its items and calculated totals.
 * @param req - The request object.
 * @param id - The ID of the order to retrieve.
 * @param code - The code of the order to retrieve.
 * @param filter - Whether to filter the keys of the order object. Default is true.
 * @returns The full order object with its items and calculated totals, or null if not found.
 */
const _order_get_full = async ( req: ILRequest, id?: string | null, code?: string | null, filter = true ) => {
	let order: OrderFull = null;

	order = await _order_get( req, id, code, null, true ) as OrderFull;

	if ( !order ) return null;

	const items: OrderItem[] = await adb_find_all( req.db, COLL_ORDER_ITEMS, { id_order: order.id }, OrderItemKeys );
	order.items = items;
	_calc_order_tots( order as Order, items );

	if ( filter ) keys_filter( order, OrderFullKeys );

	return order;
};

/**
 * Adds a product to an order and returns the updated order with all its items.
 * @param req - The request object.
 * @param order - The order object to which the product will be added.
 * @param prod_code - The product code of the product to be added.
 * @param qnt - The quantity of the product to be added.
 * @param overwrite - Whether to overwrite the quantity of the product if it already exists in the order. Default is false.
 * @returns A Promise that resolves with the updated order object with all its items.
 */
const _add_prod = ( req: ILRequest, order: Order, prod_code: string, qnt: number, overwrite = false ): Promise<OrderFull> => {
	return new Promise( async ( resolve, reject ) => {
		const err = { message: 'Product not found' };
		const prod: Product = await product_get( req, null, prod_code );

		if ( !prod ) return reject( err );

		let order_item: OrderItem = null;

		if ( overwrite ) {
			await adb_del_one( req.db, COLL_ORDER_ITEMS, { id_order: order.id, prod_code } );
		}

		if ( prod.single ) {
			await adb_del_one( req.db, COLL_ORDER_ITEMS, { id_order: order.id, prod_code } );
			qnt = 1;
		} else {
			order_item = await adb_find_one( req.db, COLL_ORDER_ITEMS, { id_order: order.id, prod_code } );
		}

		if ( !order_item ) order_item = { id: mkid( 'oitem' ), domain: order.domain, quant: 0 };

		console.log( "=== ADD PROD: ", prod.code, prod.image );

		order_item.name = prod.name;
		order_item.id_order = order.id;
		order_item.prod_code = prod.code;
		order_item.quant += qnt;
		order_item.image = prod.image;

		// Original price is saved to see discount
		order_item.orig_price_net = prod.price_net;
		order_item.orig_price_vat = prod.price_vat;
		order_item.orig_total_net = order_item.orig_price_net * order_item.quant;
		order_item.orig_total_vat = order_item.orig_price_vat * order_item.quant;

		// In the order_item the "price_net/vat" is the price with discount
		order_item.price_net = prod.curr_price_net ?? prod.price_net;
		order_item.price_vat = prod.curr_price_vat ?? prod.price_vat;
		order_item.total_net = order_item.price_net * order_item.quant;
		order_item.total_vat = order_item.price_vat * order_item.quant;

		order_item.vat = prod.vat;

		await adb_record_add( req.db, COLL_ORDER_ITEMS, order_item );
		const items: OrderItem[] = await _calc_order_tots_fetch( req, order );

		return resolve( { ...order, items } as OrderFull );
	} );
};

/**
 * Calculates the total of an order and its items, and saves the order to the database.
 * @param req - The request object.
 * @param order - The order object to calculate the total for.
 * @returns An array of order items.
 */
const _calc_order_tots_fetch = async ( req: ILRequest, order: Order ) => {
	const items: OrderItem[] = await adb_find_all( req.db, COLL_ORDER_ITEMS, { id_order: order.id }, OrderItemKeys );

	_calc_order_tots( order, items );

	await adb_record_add( req.db, COLL_ORDERS, order );

	return items;
};

/**
 * Calculates the total values for an order based on its items.
 * @param order - The order object to calculate the totals for.
 * @param items - An array of order items to calculate the totals from.
 */
const _calc_order_tots = ( order: Order, items: OrderItem[] ) => {
	let elems = 0;
	let tot_net = 0;
	let tot_vat = 0;
	let orig_tot_vat = 0;

	if ( items ) {
		items.forEach( ( it: OrderItem ) => {
			elems += it.quant;
			tot_net += it.total_net;
			tot_vat += it.total_vat;
			orig_tot_vat += it.orig_total_vat;
		} );
	}

	order.num_items = elems;
	order.total_net = tot_net;
	order.total_vat = tot_vat;
	order.original_total_vat = orig_tot_vat;
	// calc discount % from original_total_vat and total_vat, as integer
	order.discount = Math.round( ( orig_tot_vat - tot_vat ) / orig_tot_vat * 100 );
};
/*=== f2c_end __file_header ===*/

// {{{ post_order_admin_add ( req: ILRequest, prod_code: string, qnt: number, id_user: string, cback: LCBack = null ): Promise<Order>
/**
 *
 * Adds order in the system.
 * This function returns the full `Order` structure
 *
 * @param prod_code - Product Code [req]
 * @param qnt - Quantity to add [req]
 * @param id_user - The ID user to add the order to [req]
 *
 * @return order: Order
 *
 */
export const post_order_admin_add = ( req: ILRequest, prod_code: string, qnt: number, id_user: string, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start post_order_admin_add ===*/
		const order: Order = await _order_get( req, null, null, id_user, false );
		/*=== f2c_end post_order_admin_add ===*/
	} );
};
// }}}

// {{{ patch_order_admin_update ( req: ILRequest, id: string, name?: string, cback: LCBack = null ): Promise<Order>
/**
 *
 * Updates the order specified by `id`.
 * This function returns the full `Order` structure
 *
 * @param id - Order ID [req]
 * @param name - Order name [opt]
 *
 * @return order: Order
 *
 */
export const patch_order_admin_update = ( req: ILRequest, id: string, name?: string, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start patch_order_admin_update ===*/

		/*=== f2c_end patch_order_admin_update ===*/
	} );
};
// }}}

// {{{ patch_order_admin_fields ( req: ILRequest, id: string, data: any, cback: LCBack = null ): Promise<Order>
/**
 *
 * The call modifies one or more fields.
 * This function returns the full `Order` structure
 *
 * @param id - The order ID [req]
 * @param data - The field / value to patch [req]
 *
 * @return order: Order
 *
 */
export const patch_order_admin_fields = ( req: ILRequest, id: string, data: any, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start patch_order_admin_fields ===*/

		/*=== f2c_end patch_order_admin_fields ===*/
	} );
};
// }}}

// {{{ get_order_admin_list ( req: ILRequest, skip: number = 0, rows: number = -1, cback: LCBack = null ): Promise<Order[]>
/**
 *
 * Returns all orders.
 * This function returns a list of full `Order` structure.
 * This function supports pagination.
 *
 * @param skip - First line to return [opt]
 * @param rows - How many rows to return [opt]
 *
 * @return orders: Order
 *
 */
export const get_order_admin_list = ( req: ILRequest, skip: number = 0, rows: number = -1, cback: LCback = null ): Promise<Order[]> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start get_order_admin_list ===*/
		const results: any[] = await adb_query_all( req.db, `
		FOR o IN orders
			FILTER o.deleted == null
			FOR u IN users
				FILTER u.id == o.id_user
				RETURN { order: o, user: { id: u.id, name: u.name, lastname: u.lastname, email: u.email, username: u.username } }`, {} );

		const orders: Order[] = results.map( ( s ) => {
			s.order.user = s.user;
			keys_remove( s.order, [ '_id', '_key', '_rev' ] );
			return s.order;
		} );

		// keys_filter( orders, OrderFullKeys );

		return cback ? cback( null, orders ) : resolve( orders );
		/*=== f2c_end get_order_admin_list ===*/
	} );
};
// }}}

// {{{ delete_order_admin_del ( req: ILRequest, id: string, cback: LCBack = null ): Promise<string>
/**
 *
 * Deletes a order from the system.
 *
 * @param id - The order id to be deleted [req]
 *
 * @return id: string
 *
 */
export const delete_order_admin_del = ( req: ILRequest, id: string, cback: LCback = null ): Promise<string> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start delete_order_admin_del ===*/
		const err = { message: 'Order not found' };
		const order: Order = await _order_get( req, id, null, null, false );

		if ( !order ) return cback ? cback( err, null ) : reject( err );

		order.deleted = new Date();

		await adb_record_add( req.db, COLL_ORDERS, order );

		return cback ? cback( null, id ) : resolve( id );
		/*=== f2c_end delete_order_admin_del ===*/
	} );
};
// }}}

// {{{ post_order_admin_tag ( req: ILRequest, id: string, tags: string[], cback: LCBack = null ): Promise<Order>
/**
 *
 * This endpoint allows you to add tags to an order.
 *
 * @param id - The order ID [req]
 * @param tags - A list of tags to be added to the user [req]
 *
 * @return order: Order
 *
 */
export const post_order_admin_tag = ( req: ILRequest, id: string, tags: string[], cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start post_order_admin_tag ===*/

		/*=== f2c_end post_order_admin_tag ===*/
	} );
};
// }}}

// {{{ post_order_add ( req: ILRequest, prod_code: string, qnt: number, overwrite?: boolean, cback: LCBack = null ): Promise<OrderFull>
/**
 *
 * Adds a product to the current order.
 * This function returns the full `Order` structure
 *
 * @param prod_code - Product Code [req]
 * @param qnt - Quantity to add [req]
 * @param overwrite - If set to `true` overwrites the quantity [opt]
 *
 * @return order: OrderFull
 *
 */
export const post_order_add = ( req: ILRequest, prod_code: string, qnt: number, overwrite?: boolean, cback: LCback = null ): Promise<OrderFull> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start post_order_add ===*/
		let order: Order = await _order_get( req );
		const orderFull: OrderFull = await _add_prod( req, order, prod_code, qnt, overwrite );

		keys_filter( orderFull, OrderFullKeys );

		return cback ? cback( null, orderFull ) : resolve( orderFull );
		/*=== f2c_end post_order_add ===*/
	} );
};
// }}}

// {{{ get_order_details ( req: ILRequest, id: string, cback: LCBack = null ): Promise<OrderFull>
/**
 *
 * Returns all order details only if the order is `visible`.
 * The order can be identified by  `id`, `code` or `code_forn`.
 * You can pass more than a field, but one is enough.
 * This function returns the full `Order` structure
 *
 * @param id - Order unique ID [req]
 *
 * @return order: OrderFull
 *
 */
export const get_order_details = ( req: ILRequest, id: string, cback: LCback = null ): Promise<OrderFull> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start get_order_details ===*/
		const order: OrderFull = await _order_get( req, id, null, null, true ) as any;
		const items: OrderItem[] = await adb_find_all( req.db, COLL_ORDER_ITEMS, { id_order: order.id }, OrderItemKeys );

		keys_filter( order, OrderFullKeys );
		order.items = items;

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end get_order_details ===*/
	} );
};
// }}}

// {{{ get_order_list ( req: ILRequest, rows: number = -1, skip: number = 0, cback: LCBack = null ): Promise<Order[]>
/**
 *
 * Returns all visible orders.
 * Orders with `visible` set to `false` are not shown.
 * This function returns a list of full `Order` structure.
 * This function supports pagination.
 *
 * @param rows - How many rows to return [opt]
 * @param skip - First line to return [opt]
 *
 * @return orders: Order
 *
 */
export const get_order_list = ( req: ILRequest, rows: number = -1, skip: number = 0, cback: LCback = null ): Promise<Order[]> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start get_order_list ===*/
		const orders: Order[] = await adb_find_all( req.db, COLL_ORDERS, { id_user: req.user.id }, OrderKeys, { skip, rows } );

		return cback ? cback( null, orders ) : resolve( orders );
		/*=== f2c_end get_order_list ===*/
	} );
};
// }}}

// {{{ get_order_cart ( req: ILRequest, cback: LCBack = null ): Promise<OrderFull>
/**
 *
 * Returns the current cart with products for the logged in user.
 * The order must be in status `new`
 *
 *
 * @return order: OrderFull
 *
 */
export const get_order_cart = ( req: ILRequest, cback: LCback = null ): Promise<OrderFull> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start get_order_cart ===*/
		const err = { message: 'Order not found' };
		const order: OrderFull = await _order_get( req, null, null, req?.user?.id, false ) as OrderFull;

		// no order, or no order in 'new' means that the cart is empty
		if ( !order || order.status != OrderStatus.new ) return cback ? cback( err ) : reject( err );

		const items: OrderItem[] = await adb_find_all( req.db, COLL_ORDER_ITEMS, { id_order: order.id }, OrderItemKeys );
		order.items = items;
		_calc_order_tots( order as Order, items );
		keys_filter( order, OrderFullKeys );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end get_order_cart ===*/
	} );
};
// }}}

// {{{ delete_order_item_del ( req: ILRequest, id_order: string, id_item: string, cback: LCBack = null ): Promise<OrderFull>
/**
 *
 * Deletes an item from an order.
 * Order must be in state `new`.
 * Only admin and order owner can delete an item from an order.
 *
 * @param id_order - The order id [req]
 * @param id_item - The item id [req]
 *
 * @return order: OrderFull
 *
 */
export const delete_order_item_del = ( req: ILRequest, id_order: string, id_item: string, cback: LCback = null ): Promise<OrderFull> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start delete_order_item_del ===*/
		const err = { message: 'Order not found' };
		const order: OrderFull = await _order_get( req, id_order ) as OrderFull;

		if ( !order ) return cback ? cback( err ) : reject( err );
		if ( order.status != OrderStatus.new ) {
			err.message = 'Order not modifiable';
			return cback ? cback( err ) : reject( err );
		}

		// TODO: also admin can delete an item
		if ( order.id_user != req.user.id ) {
			err.message = 'You are not the owner of this order';
			return cback ? cback( err ) : reject( err );
		}

		await adb_del_one( req.db, COLL_ORDER_ITEMS, { id: id_item } );

		const items: OrderItem[] = await _calc_order_tots_fetch( req, order as Order );

		await adb_record_add( req.db, COLL_ORDERS, order );

		order.items = items;

		keys_filter( order, OrderFullKeys );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end delete_order_item_del ===*/
	} );
};
// }}}

// {{{ post_order_transaction_start ( req: ILRequest, id_order: string, challenge: string, payment_mode: string, transaction_id: string, session_id?: string, cback: LCBack = null ): Promise<OrderPaymentLog>
/**
 *
 * The `challenge` parameter is a challenge hash created composing
 * `id_order`, `transaction_id`, `session_id`, `payment_mode` as set in the `data.json` config file under `security / remote`).
 *
 * @param id_order - The order ID [req]
 * @param challenge - The challenge verification code [req]
 * @param payment_mode - The payment mode [req]
 * @param transaction_id - The transaction ID [req]
 * @param session_id - The session ID (if any) [opt]
 *
 * @return log: OrderPaymentLog
 *
 */
export const post_order_transaction_start = ( req: ILRequest, id_order: string, challenge: string, payment_mode: string, transaction_id: string, session_id?: string, cback: LCback = null ): Promise<OrderPaymentLog> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start post_order_transaction_start ===*/
		const err = { message: 'Invalid challenge' };

		console.log( "=== ORDER TRANSACTION START: ", id_order );

		if ( !challenge_check( challenge, [ id_order, transaction_id, session_id, payment_mode ] ) ) return cback ? cback( err ) : reject( err );

		const order = await order_transaction_start( req, id_order, payment_mode, transaction_id, session_id, 'transaction.start' );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end post_order_transaction_start ===*/
	} );
};
// }}}

// {{{ post_order_transaction_update ( req: ILRequest, challenge: string, payment_mode: string, transaction_id: string, session_id?: string, event_name?: string, data?: any, cback: LCBack = null ): Promise<OrderPaymentLog>
/**
 *
 * The `challenge` parameter is a `MD5` hash created composing (`email` + `name` + `remote_secret_key` as set in the `data.json` config file under `security / remote`).
 *
 * @param challenge - The challenge verification code [req]
 * @param payment_mode - The payment mode [req]
 * @param transaction_id - The transaction ID [req]
 * @param session_id - The session ID (if any) [opt]
 * @param event_name - The event name [opt]
 * @param data - The JSON data [opt]
 *
 * @return log: OrderPaymentLog
 *
 */
export const post_order_transaction_update = ( req: ILRequest, challenge: string, payment_mode: string, transaction_id: string, session_id?: string, event_name?: string, data?: any, cback: LCback = null ): Promise<OrderPaymentLog> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start post_order_transaction_update ===*/
		const err = { message: 'Invalid challenge' };

		if ( !challenge_check( challenge, [ payment_mode, transaction_id, session_id ] ) ) return cback ? cback( err ) : reject( err );

		const order: Order = await order_get_by_transaction_id( req, transaction_id, session_id, payment_mode );

		if ( !order ) {
			err.message = 'Order not found';
			return cback ? cback( err ) : reject( err );
		}

		const td = await order_transaction_update( req, order.id, transaction_id, session_id, event_name, data );

		return cback ? cback( null, td ) : resolve( td );
		/*=== f2c_end post_order_transaction_update ===*/
	} );
};
// }}}

// {{{ post_order_transaction_success ( req: ILRequest, challenge: string, transaction_id: string, session_id?: string, payment_mode?: string, cback: LCBack = null ): Promise<Order>
/**
 *
 * Mark an order as "success"
 *
 * @param challenge - Authorization challenge [req]
 * @param transaction_id - The transaction ID [req]
 * @param session_id - The session ID (if any) [opt]
 * @param payment_mode - The payment mode [opt]
 *
 * @return order: Order
 *
 */
export const post_order_transaction_success = ( req: ILRequest, challenge: string, transaction_id: string, session_id?: string, payment_mode?: string, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start post_order_transaction_success ===*/
		const err = { message: 'Invalid challenge' };

		if ( !challenge_check( challenge, [ transaction_id, session_id, payment_mode ] ) ) return cback ? cback( err ) : reject( err );

		let order: Order = await order_get_by_transaction_id( req, transaction_id, session_id, payment_mode );

		if ( !order ) {
			err.message = 'Order not found';
			return cback ? cback( err ) : reject( err );
		}

		order = await order_payment_completed( req, order.id );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end post_order_transaction_success ===*/
	} );
};
// }}}

// {{{ post_order_transaction_failed ( req: ILRequest, challenge: string, transaction_id: string, session_id?: string, payment_mode?: string, cback: LCBack = null ): Promise<Order>
/**
 *
 * Mark an order with "payment failed"
 *
 * @param challenge - Authorization challenge [req]
 * @param transaction_id - The transaction ID [req]
 * @param session_id - The Session ID [opt]
 * @param payment_mode - The payment mode [opt]
 *
 * @return order: Order
 *
 */
export const post_order_transaction_failed = ( req: ILRequest, challenge: string, transaction_id: string, session_id?: string, payment_mode?: string, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start post_order_transaction_failed ===*/
		const err = { message: 'Invalid challenge' };

		if ( !challenge_check( challenge, [ transaction_id, session_id, payment_mode ] ) ) return cback ? cback( err ) : reject( err );

		let order: Order = await order_get_by_transaction_id( req, transaction_id, session_id, payment_mode );

		if ( !order ) {
			err.message = 'Order not found';
			return cback ? cback( err ) : reject( err );
		}

		order = await order_payment_cancelled( req, order.id );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end post_order_transaction_failed ===*/
	} );
};
// }}}

// {{{ get_order_admin_details ( req: ILRequest, id: string, cback: LCBack = null ): Promise<OrderFull>
/**
 *
 * @param id - The order ID [req]
 *
 * @return order: OrderFull
 *
 */
export const get_order_admin_details = ( req: ILRequest, id: string, cback: LCback = null ): Promise<OrderFull> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start get_order_admin_details ===*/
		const order: OrderFull = await _order_get_full( req, id );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end get_order_admin_details ===*/
	} );
};
// }}}

// {{{ delete_order_admin_del_real ( req: ILRequest, id: string, cback: LCBack = null ): Promise<string>
/**
 *
 * Deletes a order from the system for real (removing everything from the database)
 *
 * @param id - The order id to be deleted [req]
 *
 * @return id: string
 *
 */
export const delete_order_admin_del_real = ( req: ILRequest, id: string, cback: LCback = null ): Promise<string> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start delete_order_admin_del_real ===*/
		// deletes all order items
		await adb_del_all( req.db, COLL_ORDER_ITEMS, { id_order: id } );

		// deletes the order
		await adb_del_one( req.db, COLL_ORDERS, { id } );

		return cback ? cback( null, id ) : resolve( id );
		/*=== f2c_end delete_order_admin_del_real ===*/
	} );
};
// }}}

// {{{ post_order_notes_add ( req: ILRequest, notes: string, id?: string, code?: string, cback: LCBack = null ): Promise<Order>
/**
 *
 * Only the current user that owns the order can add notes to the order itself.
 * The order can be referenced by `id` or `code`
 *
 * @param notes - Order notes [req]
 * @param id - Order ID [opt]
 * @param code - Order code [opt]
 *
 * @return order: Order
 *
 */
export const post_order_notes_add = ( req: ILRequest, notes: string, id?: string, code?: string, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start post_order_notes_add ===*/
		const err: ILError = { message: 'Order not found' };
		const order: Order = await _order_get( req, id, code );

		if ( !order ) return cback ? cback( err ) : reject( err );

		if ( order.id_user != req.user.id ) {
			err.message = 'You are not the owner of this order';
			return cback ? cback( err ) : reject( err );
		}

		order.notes = notes;

		await adb_record_add( req.db, COLL_ORDERS, order, OrderKeys );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end post_order_notes_add ===*/
	} );
};
// }}}

// {{{ post_order_set_delivery_address ( req: ILRequest, id: string, address: any, cback: LCBack = null ): Promise<Order>
/**
 *
 * Set inside the `order` structure the delivery address.
 * Only the order owner can call this (or admin)
 *
 * @param id - Order ID [req]
 * @param address - Delivery address [req]
 *
 * @return order: Order
 *
 */
export const post_order_set_delivery_address = ( req: ILRequest, id: string, address: any, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start post_order_set_delivery_address ===*/
		const err: ILError = { message: 'Order not found' };
		let order: Order = await _order_get( req, id );

		if ( !order ) return cback ? cback( err ) : reject( err );

		console.log( "=== OWNER: order.id_user: ", order.id_user, " req.user.id: ", req.user.id );

		if ( ( order.id_user != req.user.id ) || ( perm_available( req.user, [ 'order.address_update' ] ) == false ) ) {
			err.message = 'You are not the owner of this order';
			return cback ? cback( err ) : reject( err );
		}

		order.address = address;

		order = await adb_record_add( req.db, COLL_ORDERS, order, OrderKeys );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end post_order_set_delivery_address ===*/
	} );
};
// }}}

// {{{ get_order_get ( req: ILRequest, challenge: string, id?: string, code?: string, cback: LCBack = null ): Promise<Order>
/**
 *
 * Return basic data by `id` or `code`
 * The `challenge` field is mandatory
 * Challenge is made by:  `id+code+secret`
 *
 * @param challenge - The challenge [req]
 * @param id - The order ID [opt]
 * @param code - The order code [opt]
 *
 * @return order: Order
 *
 */
export const get_order_get = ( req: ILRequest, challenge: string, id?: string, code?: string, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start get_order_get ===*/
		const err = { message: 'Invalid challenge' };

		if ( !challenge_check( challenge, [ id, code ] ) ) return cback ? cback( err ) : reject( err );

		const order: Order = await _order_get( req, id, code );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end get_order_get ===*/
	} );
};
// }}}

// {{{ order_transaction_start ( req: ILRequest, id_order: string, payment_mode: string, transaction_id: string, session_id?: string, event_name?: string, data?: any, cback: LCBack = null ): Promise<OrderPaymentLog>
/**
 *
 * Starts a transaction for the given order.
 *
 * @param req - the Request field [req]
 * @param id_order - The order ID [req]
 * @param payment_mode - The payment mode [req]
 * @param transaction_id - The transatction id [req]
 * @param session_id - The session ID [opt]
 * @param event_name - The event name [opt]
 * @param data - Additional data [opt]
 *
 * @return : OrderPaymentLog
 *
 */
export const order_transaction_start = ( req: ILRequest, id_order: string, payment_mode: string, transaction_id: string, session_id?: string, event_name?: string, data?: any, cback: LCback = null ): Promise<OrderPaymentLog> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start order_transaction_start ===*/
		const order: Order = await _order_get( req, id_order );
		const log: OrderPaymentLog = {
			id: mkid( 'trns' ),
			id_order,
			payment_mode,
			transaction_id,
			session_id,
			event_name,
			data,
		};

		order.payment_status = OrderPaymentStatus.in_pay;
		order.payment_mode = payment_mode;
		order.transaction_id = transaction_id;

		await adb_record_add( req.db, COLL_ORDERS, order );
		const log2 = await adb_record_add( req.db, COLL_ORDER_LOG, log, OrderPaymentLogKeys );

		return cback ? cback( null, log2 ) : resolve( log2 );
		/*=== f2c_end order_transaction_start ===*/
	} );
};
// }}}

// {{{ order_transaction_update ( req: ILRequest, id_order: string, transaction_id: string, session_id?: string, event_name?: string, data?: any, cback: LCBack = null ): Promise<OrderPaymentLog>
/**
 *
 * Updates the status of a transaction
 *
 * @param req - the Request field [req]
 * @param id_order - The ID order [req]
 * @param transaction_id - The transaction ID [req]
 * @param session_id - The session ID [opt]
 * @param event_name - The event name [opt]
 * @param data - Additional data [opt]
 *
 * @return : OrderPaymentLog
 *
 */
export const order_transaction_update = ( req: ILRequest, id_order: string, transaction_id: string, session_id?: string, event_name?: string, data?: any, cback: LCback = null ): Promise<OrderPaymentLog> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start order_transaction_update ===*/
		let log: OrderPaymentLog = {
			id: mkid( 'trns' ),
			id_order,
			transaction_id,
			session_id,
			event_name,
			data,
			payment_mode: null,
		};

		log = await adb_record_add( req.db, COLL_ORDER_LOG, log, OrderPaymentLogKeys );

		return cback ? cback( null, log ) : resolve( log );
		/*=== f2c_end order_transaction_update ===*/
	} );
};
// }}}

// {{{ order_payment_completed ( req: ILRequest, id_order: string, cback: LCBack = null ): Promise<Order>
/**
 *
 * Marks an order as paid completely.
 *
 * @param req - the Request field [req]
 * @param id_order - The Order ID [req]
 *
 * @return : Order
 *
 */
export const order_payment_completed = ( req: ILRequest, id_order: string, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start order_payment_completed ===*/
		const err = { message: "Order not found" };
		let order: Order = await _order_get( req, id_order );

		if ( !order ) return cback ? cback( err ) : reject( err );

		order.payment_status = OrderPaymentStatus.paid;
		order.status = OrderStatus.ready;

		order = await adb_record_add( req.db, COLL_ORDERS, order, OrderKeys );

		await liwe_event_emit( req, ORDER_EVENT_PAID, order );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end order_payment_completed ===*/
	} );
};
// }}}

// {{{ order_payment_cancelled ( req: ILRequest, id_order: string, cback: LCBack = null ): Promise<Order>
/**
 *
 * This function marks an order as 'cancelled'
 *
 * @param req - the Request field [req]
 * @param id_order -  [req]
 *
 * @return : Order
 *
 */
export const order_payment_cancelled = ( req: ILRequest, id_order: string, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start order_payment_cancelled ===*/
		const err = { message: "Order not found" };
		let order: Order = await _order_get( req, id_order );

		if ( !order ) return cback ? cback( err ) : reject( err );

		order.payment_status = OrderPaymentStatus.aborted;
		order = await adb_record_add( req.db, COLL_ORDERS, order, OrderKeys );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end order_payment_cancelled ===*/
	} );
};
// }}}

// {{{ order_get_by_transaction_id ( req: ILRequest, transaction_id?: string, session_id?: string, payment_mode?: string, cback: LCBack = null ): Promise<Order>
/**
 *
 * Returns the order with the `transaction_id` / `session_id` specified.
 * To avoid duplicates, you can also specify the `payment_mode` but it is optional.
 * At least one between `transaction_id` and `session_id` must be specified.
 *
 * @param req - the Request field [req]
 * @param transaction_id - The transaction ID [opt]
 * @param session_id - The session ID [opt]
 * @param payment_mode - The payment mode [opt]
 *
 * @return : Order
 *
 */
export const order_get_by_transaction_id = ( req: ILRequest, transaction_id?: string, session_id?: string, payment_mode?: string, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start order_get_by_transaction_id ===*/
		const err = { message: "Order not found" };
		const order: Order = await adb_find_one( req.db, COLL_ORDERS, { transaction_id, payment_mode }, OrderKeys );

		// console.log( "===== TRANSACTION: ", order );

		if ( !order || ( !transaction_id && !payment_mode ) ) return cback ? cback( err ) : reject( err );
		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end order_get_by_transaction_id ===*/
	} );
};
// }}}

// {{{ order_get_full ( req: ILRequest, id: string, cback: LCBack = null ): Promise<OrderFull>
/**
 *
 * @param req - the Request field [req]
 * @param id - The order ID [req]
 *
 * @return : OrderFull
 *
 */
export const order_get_full = ( req: ILRequest, id: string, cback: LCback = null ): Promise<OrderFull> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start order_get_full ===*/
		const err = { message: "Order not found" };
		const order: OrderFull = await _order_get_full( req, id );

		if ( !order ) return cback ? cback( err ) : reject( err );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end order_get_full ===*/
	} );
};
// }}}

// {{{ order_add_product ( req: ILRequest, id_order: string, id_product: string, qnt: number = 1, cback: LCBack = null ): Promise<OrderFull>
/**
 *
 * @param req - the Request field [req]
 * @param id_order - The order ID [req]
 * @param id_product - The product ID [req]
 * @param qnt - Quantity [opt]
 *
 * @return : OrderFull
 *
 */
export const order_add_product = ( req: ILRequest, id_order: string, id_product: string, qnt: number = 1, cback: LCback = null ): Promise<OrderFull> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start order_add_product ===*/
		const err = { message: "Order not found" };
		let order: Order = await _order_get( req, id_order );

		if ( !order ) return cback ? cback( err ) : reject( err );

		if ( order.status != OrderStatus.new ) {
			err.message = 'Order not modifiable';
			return cback ? cback( err ) : reject( err );
		}

		const prod = await product_get( req, id_product );

		const orderFull: OrderFull = await _add_prod( req, order, prod.code, qnt );

		keys_filter( orderFull, OrderFullKeys );

		return cback ? cback( null, orderFull ) : resolve( orderFull );
		/*=== f2c_end order_add_product ===*/
	} );
};
// }}}

// {{{ order_get_open ( req: ILRequest, cback: LCBack = null ): Promise<OrderFull>
/**
 *
 * @param req - the Request field [req]
 *
 * @return : OrderFull
 *
 */
export const order_get_open = ( req: ILRequest, cback: LCback = null ): Promise<OrderFull> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start order_get_open ===*/
		const order: OrderFull = await _order_get_full( req );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end order_get_open ===*/
	} );
};
// }}}

// {{{ order_set_status ( req: any, id: string, status: any, cback: LCBack = null ): Promise<Order>
/**
 *
 * @param req -  [req]
 * @param id - Order ID [req]
 * @param status - The order status [req]
 *
 * @return : Order
 *
 */
export const order_set_status = ( req: any, id: string, status: any, cback: LCback = null ): Promise<Order> => {
	return new Promise( async ( resolve, reject ) => {
		/*=== f2c_start order_set_status ===*/
		const err = { message: 'Order not found' };
		const order: Order = await _order_get( null, id );

		if ( !order ) return cback ? cback( err ) : reject( err );

		order.status = status;

		await adb_record_add( req.db, COLL_ORDERS, order, OrderKeys );

		return cback ? cback( null, order ) : resolve( order );
		/*=== f2c_end order_set_status ===*/
	} );
};
// }}}

// {{{ order_db_init ( liwe: ILiWE, cback: LCBack = null ): Promise<boolean>
/**
 *
 * Initializes the module's database
 *
 * @param liwe - The Liwe object [req]
 *
 * @return : boolean
 *
 */
export const order_db_init = ( liwe: ILiWE, cback: LCback = null ): Promise<boolean> => {
	return new Promise( async ( resolve, reject ) => {
		_liwe = liwe;

		system_permissions_register( 'order', _module_perms );

		await adb_collection_init( liwe.db, COLL_ORDERS, [
			{ type: "persistent", fields: [ "id" ], unique: true },
			{ type: "persistent", fields: [ "domain" ], unique: false },
			{ type: "persistent", fields: [ "code" ], unique: true },
			{ type: "persistent", fields: [ "id_user" ], unique: false },
			{ type: "persistent", fields: [ "session" ], unique: false },
			{ type: "persistent", fields: [ "status" ], unique: false },
			{ type: "persistent", fields: [ "valid" ], unique: false },
			{ type: "persistent", fields: [ "payment_mode" ], unique: false },
			{ type: "persistent", fields: [ "transaction_id" ], unique: false },
			{ type: "persistent", fields: [ "session_id" ], unique: false },
			{ type: "persistent", fields: [ "payment_status" ], unique: false },
			{ type: "persistent", fields: [ "deleted" ], unique: false },
		], { drop: false } );

		await adb_collection_init( liwe.db, COLL_ORDER_ITEMS, [
			{ type: "persistent", fields: [ "id" ], unique: true },
			{ type: "persistent", fields: [ "domain" ], unique: false },
			{ type: "persistent", fields: [ "id_order" ], unique: false },
			{ type: "persistent", fields: [ "prod_code" ], unique: false },
		], { drop: false } );

		await adb_collection_init( liwe.db, COLL_ORDER_LOG, [
			{ type: "persistent", fields: [ "id" ], unique: true },
			{ type: "persistent", fields: [ "id_order" ], unique: false },
			{ type: "persistent", fields: [ "payment_mode" ], unique: false },
			{ type: "persistent", fields: [ "transaction_id" ], unique: false },
			{ type: "persistent", fields: [ "session_id" ], unique: false },
			{ type: "persistent", fields: [ "event_name" ], unique: false },
		], { drop: false } );

		/*=== f2c_start order_db_init ===*/

		/*=== f2c_end order_db_init ===*/
	} );
};
// }}}


